<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Simulation Viewer</title>

  <!-- Optional: your unified CSS (keep if you have it) -->
  <!-- <link rel="stylesheet" href="assets/viewer.css"/> -->

  <!-- Plotly.js CDN -->
  <script src="https://cdn.plot.ly/plotly-3.1.0.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    /* ===== Minimal built-in styles so it looks good even without external CSS ===== */
    :root {
      --bg1: #0f1226; --bg2: #171a36; --bg3: #0b0f22;
      --grid-gap: 14px;
    }
    html, body {
      margin: 0; padding: 0; height: 100%;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      color: #0b1220;
      background:
        radial-gradient(1200px 800px at 20% 10%, #20265b 0%, transparent 60%),
        radial-gradient(1000px 700px at 80% 20%, #103b5f 0%, transparent 60%),
        radial-gradient(1200px 900px at 50% 100%, #1b3266 0%, transparent 60%),
        linear-gradient(160deg, var(--bg1), var(--bg2) 40%, var(--bg3) 100%);
      transition: color .3s ease, background .3s ease;
    }
    html.dark, html.dark body { color: #e8eaf6; }

    .wrap { min-height: 100%; padding: 16px; max-width: 1500px; margin: 0 auto; }
    .toolbar { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    input[type="range"] { flex: 1; }

    .card {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.20);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: inherit;
    }
    html.dark .card {
      background: rgba(255,255,255,0.06);
      border-color: rgba(255,255,255,0.16);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      gap: var(--grid-gap);
      margin-top: 12px;
    }
    .card.plot { height: 360px; padding: 8px 8px 4px 8px; }
    #globe { height: 620px; }

    button {
      border: 0; border-radius: 12px; padding: 10px 16px;
      font-weight: 700; letter-spacing: .3px; cursor: pointer;
      color: #0b1220;
      background: linear-gradient(135deg, #7aa2ff, #6ae3ff);
      box-shadow: 0 8px 20px rgba(122,162,255,0.35);
      transition: transform .08s ease, filter .2s ease;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }

    .brand { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    .brand .logo { width: 50px; height: 50px; border-radius: 12px; object-fit: contain;
      background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    h1 { margin: 0; font-size: clamp(22px, 3vw, 32px); letter-spacing: .2px; }
    .lead { margin: 6px 0 14px 0; opacity: .9; line-height: 1.6; }
  </style>
</head>
<body>
<div class="wrap">
  <!-- Top controls -->
  <div class="toolbar card">
    <div class="brand">
      <img class="logo" src="assets/logo.jpg" alt="Logo">
      <h1>Simulation Viewer</h1>
    </div>
    <div style="flex:1"></div>
    <button id="play">‚èµ Play</button>
    <button id="pause">‚è∏ Pause</button>
    <label>Step
      <select id="step">
        <option value="1">1</option>
        <option value="10">10</option>
        <option value="50">50</option>
      </select>
    </label>
    <input id="slider" type="range" min="0" max="0" step="1" value="0"/>
    <button id="export" style="margin-right: 4px;">‚¨á Export</button>
    <button id="theme">üåì Theme</button>
  </div>

  <!-- Info -->
  <div id="info" class="card lead"></div>

  <!-- Globe -->
  <div id="globe" class="card"></div>

  <!-- Time series -->
  <div class="grid">
    <div id="Gini"       class="card plot"></div>
    <div id="HHI"      class="card plot"></div>
    <div id="liveness"  class="card plot"></div>
    <div id="CV"        class="card plot"></div>
    <div id="clusters"   class="card plot"></div>
    <div id="totaldist"  class="card plot"></div>
    <div id="avgnnd"     class="card plot"></div>
    <div id="nni"        class="card plot"></div>
    <div id="mev"        class="card plot"></div>
    <div id="attest"     class="card plot"></div>
    <div id="failed"     class="card plot"></div>
    <div id="proposal"   class="card plot"></div>
    <div id="relaydist"  class="card plot"></div>
  </div>
</div>

<script>
/* ============================
   URL + localStorage settings
   ============================ */
// Read settings from URL or localStorage (optional)
function readSettings() {
  const qs = new URLSearchParams(location.search);
  let ls = null;
  try { ls = JSON.parse(localStorage.getItem('app_settings') || 'null'); } catch (_) {}

  const base = {
    dataset: 'simulations/test/data.json',
    theme: 'auto',    // 'auto'|'light'|'dark'
    step: 1,
    autoplay: false,
    decimation: 5,    // border decimation
    density_radius: 0.2
  };
  const fromQS = {
    dataset: qs.get('dataset') || "data.json",
    theme: qs.get('theme') || undefined,
    step: qs.get('step') ? Number(qs.get('step')) : undefined,
    autoplay: qs.get('autoplay') ? (qs.get('autoplay') === 'true') : undefined,
    decimation: qs.get('decimation') ? Number(qs.get('decimation')) : undefined,
    density_radius: qs.get('radius') ? Number(qs.get('radius')) : undefined
  };
  return Object.assign(base, ls || {}, fromQS);
}

const SETTINGS = readSettings();
let dark = (SETTINGS.theme === 'dark')
        || (SETTINGS.theme === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);

/* ============================
   App State
   ============================ */
let DATA = null;
let WORLD_BORDER_TRACES = null;
let playing = !!SETTINGS.autoplay;
let slot = 0;
let stepSize = SETTINGS.step || 1;

let nSlots = 1;
let FULL_X = [0];

let SPHERE = null;

let RELAY_X = [], RELAY_Y = [], RELAY_Z = [];
let RELAY_NAMES = [];

let plotsReady = false;
let globeReady = false;

let RAW_GEOJSON = null;
let RAW_GCP_CSV = null;
let RAW_DATA_JSON = null;

/* ============================
   Theme helpers for Plotly
   ============================ */
// Unified Plotly-internal color/typography per theme
function plotlyTheme(isDark, title = '', yTitle = '') {
  if (isDark) {
    return {
      title,
      paper_bgcolor: '#1e1e1e',
      plot_bgcolor:  '#1e1e1e',
      font: { color: '#f0f0f0', size: 12 },
      colorway: ['#60a5fa','#fbbf24','#34d399','#a78bfa','#f472b6'],
      xaxis: { title: { text: 'Slot' }, gridcolor: '#444444', tickfont: { size: 11 } },
      yaxis: { title: { text: yTitle }, gridcolor: '#444444', tickfont: { size: 11 } }
    };
  } else {
    return {
      title,
      paper_bgcolor: 'rgba(255,255,255,0.7)',
      plot_bgcolor:  'rgba(255,255,255,0.7)',
      font: { color: '#0b1220', size: 12 },
      colorway: ['#3b82f6','#f59e0b','#10b981','#8b5cf6','#ef4444'],
      xaxis: { title: { text: 'Slot' }, gridcolor: '#e0e0e0', tickfont: { size: 11 } },
      yaxis: { title: { text: yTitle }, gridcolor: '#e0e0e0', tickfont: { size: 11 } }
    };
  }
}

/* ============================
   Utilities
   ============================ */
function linspace(a, b, n) {
  const step = (b - a) / (n - 1);
  return Array.from({length: n}, (_, i) => a + i * step);
}

function sphereGrid(phiArr, thetaArr) {
  const XS = [], YS = [], ZS = [];
  for (let i = 0; i < thetaArr.length; i++) {
    const rowX = [], rowY = [], rowZ = [];
    for (let j = 0; j < phiArr.length; j++) {
      const phi = phiArr[j], th = thetaArr[i];
      rowX.push(Math.sin(phi) * Math.cos(th));
      rowY.push(Math.sin(phi) * Math.sin(th));
      rowZ.push(Math.cos(phi));
    }
    XS.push(rowX); YS.push(rowY); ZS.push(rowZ);
  }
  return {XS, YS, ZS};
}

function latlonToXYZ(latDeg, lonDeg) {
  const phi = latDeg * Math.PI / 180;
  const theta = lonDeg * Math.PI / 180;
  return [Math.cos(phi) * Math.cos(theta), Math.cos(phi) * Math.sin(theta), Math.sin(phi)];
}

function decimate(coords, step) {
  if (step <= 1) return coords;
  const out = [];
  for (let i = 0; i < coords.length; i += step) out.push(coords[i]);
  if (coords.length && out[out.length - 1] !== coords[coords.length - 1]) out.push(coords[coords.length - 1]);
  return out;
}

function calculateDensity(points, radius = 0.2) {
    const n = points.length;
    const densities = new Array(n).fill(0);
    
    // We use the square of the radius to avoid calculating Math.sqrt() 
    // inside the loop, which significantly improves performance.
    const thresholdSq = radius * radius;

    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            // Calculate squared Euclidean distance between point i and point j
            const dx = points[i][0] - points[j][0];
            const dy = points[i][1] - points[j][1];
            const dz = points[i][2] - points[j][2];
            
            const distSq = dx * dx + dy * dy + dz * dz;

            // If the distance is within the threshold, increment density for both points
            if (distSq <= thresholdSq) {
                densities[i]++;
                densities[j]++;
            }
        }
    }
    return densities;
}

/* ============================
   Data loading
   ============================ */
async function loadGCPData() {
    const csvUrl = './data/gcp_regions.csv';

    // fetch once so we can also export the same CSV later
    const resp = await fetch(csvUrl, { cache: 'no-cache' });
    if (!resp.ok) throw new Error(`Failed to load ${csvUrl}`);
    RAW_GCP_CSV = await resp.text();

    return new Promise((resolve, reject) => {
        Papa.parse(RAW_GCP_CSV, {
            header: true,         // Parse headers automatically
            skipEmptyLines: true, // Skip empty lines
            
            // Callback when parsing is finished
            complete: function(results) {
                const dataMap = new Map();

                results.data.forEach(row => {
                    const key = row.Region; 

                    if (key) {
                        dataMap.set(key, row);
                    }
                });

                resolve(dataMap);
            },
            
            error: function(err) {
                reject(err);
            }
        });
    });
}

async function loadData() {
  const resp = await fetch(SETTINGS.dataset, { cache: 'no-cache' });
  if (!resp.ok) throw new Error(`Failed to load ${SETTINGS.dataset}`);
  RAW_DATA_JSON = await resp.text();
  DATA = JSON.parse(RAW_DATA_JSON);

  DATA.gcpData = await loadGCPData();

  const gcpXYZ = new Map();
  for (const [k, v] of DATA.gcpData.entries()) {
    const x = Number(v.x), y = Number(v.y), z = Number(v.z);
    if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) {
      gcpXYZ.set(String(k), [x, y, z]);
    }
  }
  DATA.gcpXYZ = gcpXYZ;

  nSlots = Math.max(
    1,
    DATA.n_slots || 0,
    DATA.metrics?.clusters?.length || 0,
    DATA.slots?.length || 0
  );
  FULL_X = Array.from({ length: nSlots }, (_, i) => i);

  document.getElementById('slider').max = String(Math.max(0, nSlots - 1));

  RELAY_NAMES = (DATA.sources || []).map(s => s[0]);
  RELAY_X = []; RELAY_Y = []; RELAY_Z = [];
  for (const src of (DATA.sources || [])) {
    const region = String(src[1]);
    const xyz = DATA.gcpXYZ.get(region);
    if (xyz) {
      RELAY_X.push(xyz[0]); RELAY_Y.push(xyz[1]); RELAY_Z.push(xyz[2]);
    } else {
      RELAY_X.push(0); RELAY_Y.push(0); RELAY_Z.push(0);
    }
  }

  const phi = linspace(0, Math.PI, 40), theta = linspace(0, 2*Math.PI, 80);
  SPHERE = sphereGrid(phi, theta);
}

async function loadWorldBorders() {
  if (WORLD_BORDER_TRACES) return WORLD_BORDER_TRACES;
  const url = 'https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json';
  const resp = await fetch(url, { cache: 'force-cache' });
  if (!resp.ok) throw new Error('Failed to load countries.geo.json');
  const gj = await resp.json();
  RAW_GEOJSON = gj;

  const tracesLight = [], tracesDark = [];
  for (const feat of gj.features) {
    const geom = feat.geometry;
    if (!geom) continue;
    const polys = (geom.type === 'Polygon') ? [geom.coordinates]
                 : (geom.type === 'MultiPolygon') ? geom.coordinates : [];
    for (const poly of polys) {
      if (!poly.length) continue;
      const ring = decimate(poly[0], SETTINGS.decimation || 5); // [[lon,lat], ...]
      if (ring.length < 2) continue;
      const xs = [], ys = [], zs = [];
      for (const [lon, lat] of ring) {
        const [x, y, z] = latlonToXYZ(lat, lon);
        xs.push(x); ys.push(y); zs.push(z);
      }
      const base = { type: 'scatter3d', mode: 'lines', x: xs, y: ys, z: zs, hoverinfo: 'skip', showlegend: false };
      tracesLight.push({ ...base, line: { width: 1, color: '#888'  } });
      tracesDark .push({ ...base, line: { width: 1, color: '#aaaaaa' } });
    }
  }
  WORLD_BORDER_TRACES = { light: tracesLight, dark: tracesDark };
  return WORLD_BORDER_TRACES;
}

/* ============================
   Plot builders
   ============================ */
function drawGlobe(i) {
  const { slots, meta, sources } = DATA;
  const xs = [], ys = [], zs = [];
  const pts = [];
  for (const [region, count] of (slots[i] || [])) {
    const xyz = DATA.gcpXYZ.get(String(region));
    if (!xyz) continue;

    const x = xyz[0], y = xyz[1], z = xyz[2];
    const n = Number(count) || 0;
    for (let k = 0; k < n; k++) {
      xs.push(x); ys.push(y); zs.push(z);
      pts.push([x, y, z]);
    }
  }

  const dens = calculateDensity(pts, SETTINGS.density_radius || 0.2);

  if (!globeReady) {
    const validators = {
      type: 'scatter3d', mode: 'markers',
      x: xs, y: ys, z: zs,
      marker: {
        size: 4,
        color: dens,
        colorscale: dark ? 'Plasma' : 'Viridis',
        showscale: true,
        colorbar: {
          title: 'Local Density', x: 1.15, len: 0.7,
          titlefont: { color: dark ? '#f0f0f0' : '#0b1220' },
          tickfont:  { color: dark ? '#f0f0f0' : '#0b1220' }
        }
      },
      name: 'Validators'
    };

    const sphere = {
      type: 'surface', x: SPHERE.XS, y: SPHERE.YS, z: SPHERE.ZS, showscale: false, opacity: 0.2,
      colorscale: [[0, dark ? '#444444' : 'lightblue'], [1, dark ? '#444444' : 'lightblue']],
      hoverinfo: 'skip', name: 'Earth'
    };

    const relays = {
      type: 'scatter3d', mode: 'markers+text',
      x: RELAY_X, y: RELAY_Y, z: RELAY_Z,
      marker: { size: 10, color: 'red', symbol: 'diamond', line: { color: 'black', width: 1 } },
      text: RELAY_NAMES, textposition: 'top center', name: 'Info Sources'
    };

    const traces = [validators, sphere, relays];

    const borders = dark ? WORLD_BORDER_TRACES.dark : WORLD_BORDER_TRACES.light;
    traces.push(...borders);

    const layout = {
      ...plotlyTheme(dark, 'Geo Tracker', ''),
      margin: { l: 15, r: 160, b: 20, t: 40 },
      uirevision: 'keep-camera',
      scene: {
        xaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
                 gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
        yaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
                 gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
        zaxis: { range: [-1,1], backgroundcolor: dark ? '#1e1e1e' : 'rgba(255,255,255,0.7)',
                 gridcolor: dark ? '#444444' : '#e0e0e0', showbackground: true, showgrid: true, showticklabels: false, zerolinecolor: dark ? '#666' : '#999' },
        aspectmode: 'cube'
      },
      showlegend: true,
      legend: { x: 0.02, y: 0.98, bgcolor: dark ? 'rgba(45,45,45,0.7)' : 'rgba(255,255,255,0.7)' }
    };

    Plotly.newPlot('globe', traces, layout, { displaylogo: false, responsive: true, displayModeBar: false });
    globeReady = true;
    return;
  }

  Plotly.restyle('globe', {
    x: [xs], y: [ys], z: [zs],
    'marker.color': [dens]
  }, [0]);
}

function drawLine(divId, x, y, title, yTitle='') {
  const el = document.getElementById(divId);
  const h  = (el.clientHeight || 360) * 0.94;
  const layout = {
    ...plotlyTheme(dark, title, yTitle),
    height: h,
    margin: { l: 60, r: 20, t: 40, b: 40 },
    hovermode: 'x unified',
    xaxis: {
      ...(plotlyTheme(dark, title, yTitle).xaxis),
      autorange: false,
      range: [0, 0]
    }
  };
  Plotly.newPlot(divId, [{
    type: 'scatter', mode: 'lines', x, y, line: { width: 2 }
  }], layout, { displaylogo: false, responsive: true, displayModeBar: false });
}

function drawRelayDist(i) {
  const el = document.getElementById('relaydist');
  const h  = (el.clientHeight || 360) * 0.94;
  const series = DATA.metrics.info_avg_distance || [];
  const names  = RELAY_NAMES || [];

  const traces = [];
  const m = Math.max(names.length, ...(series || []).map(arr => (arr || []).length), 0);
  for (let j = 0; j < m; j++) {
    const y = new Array(nSlots).fill(null);
    for (let t = 0; t < nSlots; t++) {
      const row = series[t];
      y[t] = (row && row[j] != null) ? row[j] : null;
    }
    traces.push({ type: 'scatter', mode: 'lines', x: FULL_X, y, name: names[j] || `Source ${j}`, line: { width: 2 } });
  }

  const layout = {
    ...plotlyTheme(dark, 'Avg Distance to Info Sources', 'Avg. Distance'),
    height: h,
    margin: { l: 60, r: 20, t: 40, b: 40 },
    hovermode: 'x unified',
    xaxis: {
      ...(plotlyTheme(dark, '', '').xaxis),
      autorange: false,
      range: [0, 0]
    },
    legend: { orientation: 'h', yanchor: 'top', y: -0.25, xanchor: 'center', x: 0.5, font: { size: 11 } }
  };
  Plotly.newPlot('relaydist', traces, layout, { displaylogo: false, responsive: true, displayModeBar: false });
}

/* ============================
   Rendering orchestration
   ============================ */
function infoHTML(i) {
  const S = DATA.metrics;
  const num = (v, d=0) => (Number.isFinite(v) ? v : d);
  return `
    <div style="display:flex;flex-wrap:wrap;gap:18px">
      <span><b>Slot</b> ${i + 1}</span>
      <span>Clusters: ${S.clusters[i]}</span>
      <span>Total Distance: ${num(S.total_distance[i]).toFixed(4)}</span>
      <span>Avg NND: ${num(S.avg_nnd[i]).toFixed(4)}</span>
      <span>NNI: ${num(S.nni[i]).toFixed(4)}</span>
      <span>MEV: ${num(S.mev[i]).toFixed(4)}</span>
      <span>Attest: ${num(S.attestations[i]).toFixed(2)}%</span>
      <span>Proposal Time: ${num(S.proposal_times[i]).toFixed(2)} ms</span>
    </div>`;
}

function updateLineWindows(i) {
  const range = i <= 0 ? [-1, -0.1] : [0, i];
  const plot_range = { 'xaxis.range': range };
  Plotly.relayout('Gini', plot_range);
  Plotly.relayout('HHI', plot_range);
  Plotly.relayout('liveness', plot_range);
  Plotly.relayout('CV', plot_range);
  Plotly.relayout('clusters', plot_range);
  Plotly.relayout('totaldist', plot_range);
  Plotly.relayout('avgnnd', plot_range);
  Plotly.relayout('nni', plot_range);
  Plotly.relayout('mev', plot_range);
  Plotly.relayout('attest', plot_range);
  Plotly.relayout('failed', plot_range);
  Plotly.relayout('proposal', plot_range);
  Plotly.relayout('relaydist', plot_range);
}

function drawAll() {
  document.getElementById('info').innerHTML = infoHTML(slot);
  document.getElementById('slider').value = String(slot);

  if (!plotsReady) {
    drawGlobe(slot);

    const S = DATA.metrics;
    drawLine('Gini', FULL_X, (S.gini || []).slice(0, nSlots), 'Gini Coefficient', 'Gini');
    drawLine('HHI', FULL_X, (S.hhi || []).slice(0, nSlots), 'HHI', 'HHI');
    drawLine('liveness', FULL_X, (S.liveness || []).slice(0, nSlots), 'Liveness Coefficient', 'Liveness Coefficient');
    drawLine('CV', FULL_X, (S.profit_variance || []).slice(0, nSlots), 'Coefficient of Variation', 'CV');
    drawLine('clusters', FULL_X, (S.clusters || []).slice(0, nSlots), 'Clusters', 'Clusters (#)');
    drawLine('totaldist', FULL_X, (S.total_distance || []).slice(0, nSlots), 'Total Distance', 'Total Distance');
    drawLine('avgnnd', FULL_X, (S.avg_nnd || []).slice(0, nSlots), 'Avg NND', 'Avg NND');
    drawLine('nni', FULL_X, (S.nni || []).slice(0, nSlots), 'NNI', 'NNI');
    drawLine('mev', FULL_X, (S.mev || []).slice(0, nSlots), 'MEV Earned', 'Block Value');
    drawLine('attest', FULL_X, (S.attestations || []).slice(0, nSlots), 'Attestation Rate %', 'Attestation Rate (%)');
    drawLine('failed', FULL_X, (S.failed_block_proposals || []).slice(0, nSlots), 'Failed Block Proposals', 'Failed Proposals (#)');
    drawLine('proposal', FULL_X, (S.proposal_times || []).slice(0, nSlots), 'Proposal Time (ms)', 'Proposal Time (ms)');

    drawRelayDist(0);

    plotsReady = true;
    updateLineWindows(slot);
  } else {
    updateLineWindows(slot);
    drawGlobe(slot);
  }
}

function tick() {
  if (playing) {
    slot = (slot + stepSize) % nSlots;
    drawAll();
  }
}

/* ============================
   Controls
   ============================ */
document.getElementById('play').onclick  = () => { playing = true;  };
document.getElementById('pause').onclick = () => { playing = false; };
document.getElementById('step').onchange = (e) => { stepSize = parseInt(e.target.value, 10) || 1; };
document.getElementById('theme').onclick = () => {
  dark = !dark;
  document.documentElement.classList.toggle('dark', dark);
  plotsReady = false;
  globeReady = false;
  drawAll();
};
document.getElementById('slider').oninput = (e) => {
  slot = parseInt(e.target.value, 10) || 0;
  playing = false;
  drawAll();
};

/* ============================
   Export button
   ============================ */
document.getElementById('export').onclick = async () => {
  if (!DATA) return;

  const zip = new JSZip();
  const btn = document.getElementById('export');
  const originalText = btn.innerText;

  btn.disabled = true;

  try {
    zip.file("data.json", RAW_DATA_JSON || JSON.stringify(DATA, null, 2));

    // Use the already fetched GeoJSON
    if (RAW_GEOJSON) {
      zip.file("countries.geo.json", JSON.stringify(RAW_GEOJSON, null, 2));
    }

    if (RAW_GCP_CSV) {
      zip.file("gcp_regions.csv", RAW_GCP_CSV);
    }

    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);

    const link = document.createElement('a');
    link.href = url;
    link.download = "geo_simulation.zip";
    document.body.appendChild(link);
    link.click();

    document.body.removeChild(link);
    URL.revokeObjectURL(url);

  } catch (err) {
    console.error("Export failed", err);
  } finally {
    btn.disabled = false;
  }
};

/* ============================
   Boot
   ============================ */
(async function boot() {
  // Apply initial theme class
  document.documentElement.classList.toggle('dark', dark);

  await loadData();
  await loadWorldBorders();
  
  drawAll();

  // Autoplay if requested
  playing = !!SETTINGS.autoplay;
  stepSize = SETTINGS.step || 1;
  setInterval(tick, 250);
})().catch(err => {
  console.error(err);
  document.body.insertAdjacentHTML('beforeend', `<pre style="color:#ffb4b4;background:#2e1a1a;padding:10px;border-radius:8px">${String(err)}</pre>`);
});
</script>
</body>
</html>
